/**
 * @file atom_joint_recorder.cpp
 * @brief Atom机器人关节数据记录器
 * @details 记录机器人所有关节角度数据到文件，支持可配置的记录参数
 * @author futingxing
 * @date 2025-09-01
 * @version 1.0.0
 * @copyright Copyright (c) 2025 Dobot. All rights reserved.
 */

#include <rclcpp/rclcpp.hpp>
#include <dobot_atom/msg/lower_state.hpp>
#include <dobot_atom/msg/upper_state.hpp>
#include <dobot_atom/msg/hands_state.hpp>
#include <fstream>
#include <vector>
#include <chrono>
#include <iomanip>

class AtomJointRecorder : public rclcpp::Node
{
public:
    AtomJointRecorder() : Node("atom_joint_recorder")
    {
        // 声明参数
        this->declare_parameter("output_file", "joint_angles.txt");
        this->declare_parameter("record_duration", 20.0);
        this->declare_parameter("init_delay", 5.0);
        this->declare_parameter("record_frequency", 100.0);
        
        // 获取参数
        output_file_ = this->get_parameter("output_file").as_string();
        record_duration_ = this->get_parameter("record_duration").as_double();
        init_delay_ = this->get_parameter("init_delay").as_double();
        record_frequency_ = this->get_parameter("record_frequency").as_double();
        
        // 订阅者
        lower_state_sub_ = this->create_subscription<dobot_atom::msg::LowerState>(
            "/lower/state", 10,
            std::bind(&AtomJointRecorder::lowerStateCallback, this, std::placeholders::_1));
        
        upper_state_sub_ = this->create_subscription<dobot_atom::msg::UpperState>(
            "/upper/state", 10,
            std::bind(&AtomJointRecorder::upperStateCallback, this, std::placeholders::_1));
        
        hands_state_sub_ = this->create_subscription<dobot_atom::msg::HandsState>(
            "/hands/state", 10,
            std::bind(&AtomJointRecorder::handsStateCallback, this, std::placeholders::_1));
        
        // 初始化状态
        recording_started_ = false;
        recording_finished_ = false;
        start_time_ = this->now();
        
        // 创建记录定时器
        double timer_period = 1.0 / record_frequency_;
        record_timer_ = this->create_wall_timer(
            std::chrono::milliseconds(static_cast<int>(timer_period * 1000)),
            std::bind(&AtomJointRecorder::recordData, this));
        
        // 打开输出文件
        output_stream_.open(output_file_);
        if (!output_stream_.is_open()) {
            RCLCPP_ERROR(this->get_logger(), "Failed to open output file: %s", output_file_.c_str());
            rclcpp::shutdown();
            return;
        }
        
        // 写入文件头
        writeFileHeader();
        
        RCLCPP_INFO(this->get_logger(), "Atom Joint Recorder initialized");
        RCLCPP_INFO(this->get_logger(), "Output file: %s", output_file_.c_str());
        RCLCPP_INFO(this->get_logger(), "Init delay: %.1f seconds", init_delay_);
        RCLCPP_INFO(this->get_logger(), "Record duration: %.1f seconds", record_duration_);
        RCLCPP_INFO(this->get_logger(), "Record frequency: %.1f Hz", record_frequency_);
        RCLCPP_INFO(this->get_logger(), "Waiting for robot state data...");
    }
    
    ~AtomJointRecorder()
    {
        if (output_stream_.is_open()) {
            output_stream_.close();
        }
    }

private:
    // ROS2 订阅者
    rclcpp::Subscription<dobot_atom::msg::LowerState>::SharedPtr lower_state_sub_;
    rclcpp::Subscription<dobot_atom::msg::UpperState>::SharedPtr upper_state_sub_;
    rclcpp::Subscription<dobot_atom::msg::HandsState>::SharedPtr hands_state_sub_;
    
    rclcpp::TimerBase::SharedPtr record_timer_;
    
    // 参数
    std::string output_file_;
    double record_duration_;
    double init_delay_;
    double record_frequency_;
    
    // 状态
    bool recording_started_;
    bool recording_finished_;
    rclcpp::Time start_time_;
    
    // 数据
    dobot_atom::msg::LowerState::SharedPtr current_lower_state_;
    dobot_atom::msg::UpperState::SharedPtr current_upper_state_;
    dobot_atom::msg::HandsState::SharedPtr current_hands_state_;
    
    // 文件输出
    std::ofstream output_stream_;
    std::vector<std::vector<double>> recorded_data_;
    
    void lowerStateCallback(const dobot_atom::msg::LowerState::SharedPtr msg)
    {
        current_lower_state_ = msg;
    }
    
    void upperStateCallback(const dobot_atom::msg::UpperState::SharedPtr msg)
    {
        current_upper_state_ = msg;
    }
    
    void handsStateCallback(const dobot_atom::msg::HandsState::SharedPtr msg)
    {
        current_hands_state_ = msg;
    }
    
    void writeFileHeader()
    {
        output_stream_ << "# Atom Robot Joint Angles Recording" << std::endl;
        output_stream_ << "# Generated by atom_joint_recorder" << std::endl;
        output_stream_ << "# Format: timestamp(s) leg_joints(12) arm_joints(17) hand_joints(12)" << std::endl;
        output_stream_ << "# Total columns: 1 + 12 + 17 + 12 = 42" << std::endl;
        output_stream_ << "# Leg joints: left_hip_pitch left_hip_roll left_hip_yaw left_knee left_ankle_pitch left_ankle_roll ";
        output_stream_ << "right_hip_pitch right_hip_roll right_hip_yaw right_knee right_ankle_pitch right_ankle_roll" << std::endl;
        output_stream_ << "# Arm joints: waist_yaw left_shoulder_pitch left_shoulder_roll left_shoulder_yaw left_elbow_pitch ";
        output_stream_ << "left_elbow_roll left_wrist_pitch left_wrist_roll right_shoulder_pitch right_shoulder_roll ";
        output_stream_ << "right_shoulder_yaw right_elbow_pitch right_elbow_roll right_wrist_pitch right_wrist_roll ";
        output_stream_ << "head_pitch head_roll" << std::endl;
        output_stream_ << "# Hand joints: left_hand(6) right_hand(6)" << std::endl;
        output_stream_ << "#" << std::endl;
    }
    
    void recordData()
    {
        if (recording_finished_) {
            return;
        }
        
        // 检查是否有必要的数据
        if (!current_lower_state_ || !current_upper_state_) {
            RCLCPP_WARN_THROTTLE(this->get_logger(), *this->get_clock(), 1000, 
                                "Waiting for robot state data...");
            return;
        }
        
        auto current_time = this->now();
        double elapsed_time = (current_time - start_time_).seconds();
        
        // 检查是否开始记录
        if (!recording_started_) {
            if (elapsed_time >= init_delay_) {
                recording_started_ = true;
                start_time_ = current_time; // 重置开始时间
                elapsed_time = 0.0;
                RCLCPP_INFO(this->get_logger(), "Started recording joint angles...");
            } else {
                RCLCPP_INFO_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
                                    "Waiting %.1f more seconds before recording...", 
                                    init_delay_ - elapsed_time);
                return;
            }
        }
        
        // 检查是否结束记录
        if (elapsed_time >= record_duration_) {
            recording_finished_ = true;
            RCLCPP_INFO(this->get_logger(), "Recording completed. Saved %zu data points to %s", 
                       recorded_data_.size(), output_file_.c_str());
            
            // 写入所有记录的数据
            writeAllData();
            
            // 关闭文件
            output_stream_.close();
            
            RCLCPP_INFO(this->get_logger(), "File saved successfully. Shutting down...");
            rclcpp::shutdown();
            return;
        }
        
        // 记录当前数据
        std::vector<double> data_point;
        
        // 添加时间戳
        data_point.push_back(elapsed_time);
        
        // 添加腿部关节角度 (12个)
        for (int i = 0; i < 12; ++i) {
            if (i < static_cast<int>(current_lower_state_->motor_state.size())) {
                data_point.push_back(current_lower_state_->motor_state[i].q);
            } else {
                data_point.push_back(0.0);
            }
        }
        
        // 添加手臂关节角度 (17个)
        for (int i = 0; i < 17; ++i) {
            if (i < static_cast<int>(current_upper_state_->motor_state.size())) {
                data_point.push_back(current_upper_state_->motor_state[i].q);
            } else {
                data_point.push_back(0.0);
            }
        }
        
        // 添加手部关节角度 (12个)
        if (current_hands_state_) {
            for (int i = 0; i < 12; ++i) {
                if (i < static_cast<int>(current_hands_state_->hands.size())) {
                    data_point.push_back(current_hands_state_->hands[i].q);
                } else {
                    data_point.push_back(0.0);
                }
            }
        } else {
            // 如果没有手部数据，填充零
            for (int i = 0; i < 12; ++i) {
                data_point.push_back(0.0);
            }
        }
        
        // 保存数据点
        recorded_data_.push_back(data_point);
        
        // 每秒输出一次进度
        if (static_cast<int>(elapsed_time * 10) % 10 == 0) {
            double progress = (elapsed_time / record_duration_) * 100.0;
            RCLCPP_INFO(this->get_logger(), "Recording progress: %.1f%% (%.1f/%.1f seconds)", 
                       progress, elapsed_time, record_duration_);
        }
    }
    
    void writeAllData()
    {
        RCLCPP_INFO(this->get_logger(), "Writing %zu data points to file...", recorded_data_.size());
        
        for (const auto& data_point : recorded_data_) {
            for (size_t i = 0; i < data_point.size(); ++i) {
                if (i > 0) {
                    output_stream_ << " ";
                }
                output_stream_ << std::fixed << std::setprecision(6) << data_point[i];
            }
            output_stream_ << std::endl;
        }
        
        output_stream_.flush();
    }
    
public:
    // 公共接口
    bool isRecordingFinished() const
    {
        return recording_finished_;
    }
    
    size_t getRecordedDataCount() const
    {
        return recorded_data_.size();
    }
};

int main(int argc, char** argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<AtomJointRecorder>();
    
    RCLCPP_INFO(node->get_logger(), "Starting Atom Joint Recorder...");
    
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}